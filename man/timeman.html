
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linux blog</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
<div class="header">
    <div class="hb">
         <a href="#" class="logo"><img src="../icons/logo.svg" alt=""></a>

            <ul class="navbar">
                <li><a href="../index.html">Pocetna</a></li>
            </ul>

    </div>
</div>
    

<div class="section-ls">
    
    <div class="naslov1">

     <a href="../html/time.html"><img src="../icons/icons8-left-30 (1).png" alt=""></a>
        <div class="man">  <b><p>time(1) - man page</p> </b>                  </div>
        <hr>
        <br>
        <br>

   <p>     NAME <br>
       time - run programs and summarize system resource usage
 
 <p>SYNOPSIS <br>
      time   [ -apqvV ] [ -f FORMAT ] [ -o FILE ] <br>
              [ --append ] [ --verbose ] [ --quiet ] [ --portability] <br>
               [ --format=FORMAT ] [ --output=FILE ] [ --version ] <br>
               [ --help ] COMMAND [ ARGS ] <br>
 
<p> DESCRIPTION <br>
        time run the program COMMAND with any given arguments ARG....
        When COMMAND finishes, time displays information about
        resources used by COMMAND (on the standard error output, by
        default).  If COMMAND exits with non-zero status, time
        displays a warning message and the exit status.
 
     <p>   time determines which information to display about the
        resources used by the COMMAND from the string FORMAT.  If no
        format is specified on the command line, but the TIME
        environment variable is set, its value is used as the format.
        Otherwise, a default format built into time is used.
 
     <p>   Options to time must appear on the command line before
        COMMAND.  Anything on the command line after COMMAND is
        passed as arguments to COMMAND.
 
<p> OPTIONS <br>
      <p>  -o FILE, --output=FILE <br>
               Write the resource use statistics to FILE instead of
               to the standard error stream.  By default, this
               overwrites the file, destroying the file's previous
               contents.  This option is useful for collecting
               information on interactive programs and programs that
               produce output on the standard error stream.
 
     <p>   -a, --append <br>
               Append the resource use information to the output file
               instead of overwriting it.  This option is only useful
               with the `-o' or `--output' option.
 
    <p>    -f FORMAT, --format FORMAT <br>
               Use FORMAT as the format string that controls the
               output of time.  See the below more information.
 
     <p>   --help Print a summary of the command line options and exit.
 
    <p>    -p, --portability <br>
               Use the following format string, for conformance with
               POSIX standard 1003.2:
                         real %e
                         user %U
                         sys %S
 
      <p>  -v, --verbose <br>
               Use the built-in verbose format, which displays each
               available piece of information on the program's
               resource use on its own line, with an English
               description of its meaning.
 
   <p>     --quiet <br>
               Do not report the status of the program even if it is
               different from zero.
 
    <p>    -V, --version <br>
               Print the version number of time and exit.
 
<p> FORMATTING THE OUTPUT <br>
        The format string FORMAT controls the contents of the time
        output.  The format string can be set using the `-f' or
        `--format', `-v' or `--verbose', or `-p' or `--portability'
        options.  If they are not given, but the TIME environment
        variable is set, its value is used as the format string.
        Otherwise, a built-in default format is used.  The default
        format is:
          %Uuser %Ssystem %Eelapsed %PCPU (%Xtext+%Ddata %Mmax)k
          %Iinputs+%Ooutputs (%Fmajor+%Rminor)pagefaults %Wswaps
 
   <p>     The format string usually consists of `resource specifiers'
        interspersed with plain text.  A percent sign (`%') in the
        format string causes the following character to be
        interpreted as a resource specifier, which is similar to the
        formatting characters in the printf(3) function.
 
   <p>     A backslash (`\') introduces a `backslash escape', which is
        translated into a single printing character upon output.
        `\t' outputs a tab character, `\n' outputs a newline, and
        `\\' outputs a backslash.  A backslash followed by any other
        character outputs a question mark (`?') followed by a
        backslash, to indicate that an invalid backslash escape was
        given.
 
     <p>   Other text in the format string is copied verbatim to the
        output.  time always prints a newline after printing the
        resource use information, so normally format strings do not
        end with a newline character (or `\n').
 
   <p>     There are many resource specifications.  Not all resources
        are measured by all versions of Unix, so some of the values
        might be reported as zero.  Any character following a percent
        sign that is not listed in the table below causes a question
        mark (`?') to be output, followed by that character, to
        indicate that an invalid resource specifier was given.
 
   <p>     The resource specifiers, which are a superset of those
        recognized by the tcsh(1) builtin `time' command, are:
        <p>       %      A literal `%'.
          <p>     C      Name and command line arguments of the command
                      being timed.
            <p>  D      Average size of the process's unshared data
                      area, in Kilobytes.
            <p>   E      Elapsed real (wall clock) time used by the
                      process, in [hours:]minutes:seconds.
            <p>   F      Number of major, or I/O-requiring, page faults
                      that occurred while the process was running.
                      These are faults where the page has actually
                      migrated out of primary memory.
            <p>   I      Number of file system inputs by the process.
            <p>   K      Average total (data+stack+text) memory use of
                      the process, in Kilobytes.
           <p>    M      Maximum resident set size of the process during
                      its lifetime, in Kilobytes.
          <p>     O      Number of file system outputs by the process.
          <p>     P      Percentage of the CPU that this job got.  This
                      is just user + system times divided by the
                      total running time.  It also prints a
                      percentage sign.
          <p>     R      Number of minor, or recoverable, page faults.
                      These are pages that are not valid (so they
                      fault) but which have not yet been claimed by
                      other virtual pages.  Thus the data in the page
                      is still valid but the system tables must be
                      updated.
           <p>    S      Total number of CPU-seconds used by the system
                      on behalf of the process (in kernel mode), in
                      seconds.
             <p>  U      Total number of CPU-seconds that the process
                      used directly (in user mode), in seconds.
            <p>   W      Number of times the process was swapped out of
                      main memory.
             <p>  X      Average amount of shared text in the process,
                      in Kilobytes.
          <p>     Z      System's page size, in bytes.  This is a
                      per-system constant, but varies between
                      systems.
          <p>     c      Number of times the process was
                      context-switched involuntarily (because the
                      time slice expired).
           <p>    e      Elapsed real (wall clock) time used by the
                      process, in seconds.
           <p>    k      Number of signals delivered to the process.
           <p>    p      Average unshared stack size of the process, in
                      Kilobytes.
            <p>   r      Number of socket messages received by the
                      process.
            <p>   s      Number of socket messages sent by the process.
         <p>      t      Average resident set size of the process, in
                      Kilobytes.
        <p>       w      Number of times that the program was
                      context-switched voluntarily, for instance
                      while waiting for an I/O operation to complete.
      <p>         x      Exit status of the command.
 
<p> EXAMPLES <br>
        To run the command `wc /etc/hosts' and show the default
        information:
             time wc /etc/hosts
 
       <p> To run the command `ls -Fs' and show just the user, system,
        and total time:
             time -f "\t%E real,\t%U user,\t%S sys" ls -Fs
 
      <p>  To edit the file BORK and have `time' append the elapsed time
        and number of signals to the file `log', reading the format
        string from the environment variable `TIME':
             export TIME="\t%E,\t%k" # If using bash or ksh
             setenv TIME "\t%E,\t%k" # If using csh or tcsh
             time -a -o log emacs bork
 
    <p>    Users of the bash shell need to use an explicit path in order
        to run the external time command and not the shell builtin
        variant.  On system where time is installed in /usr/bin, the
        first example would become
             /usr/bin/time wc /etc/hosts
 
 <p>ACCURACY <br>
        The elapsed time is not collected atomically with the
        execution of the program; as a result, in bizarre
        circumstances (if the time command gets stopped or swapped
        out in between when the program being timed exits and when
        time calculates how long it took to run), it could be much
        larger than the actual execution time.
 
     <p>   When the running time of a command is very nearly zero, some
        values (e.g., the percentage of CPU used) may be reported as
        either zero (which is wrong) or a question mark.
 
   <p>     Most information shown by time is derived from the wait3(2)
        system call.  The numbers are only as good as those returned
        by wait3(2).  On systems that do not have a wait3(2) call
        that returns status information, the times(2) system call is
        used instead.  However, it provides much less information
        than wait3(2), so on those systems time reports the majority
        of the resources as zero.
 
   <p>     The `%I' and `%O' values are allegedly only `real' input and
        output and do not include those supplied by caching devices.
        The meaning of `real' I/O reported by `%I' and `%O' may be
        muddled for workstations, especially diskless ones.
 
 <p>DIAGNOSTICS <br>
        The time command returns when the program exits, stops, or is
        terminated by a signal.  If the program exited normally, the
        return value of time is the return value of the program it
        executed and measured.  Otherwise, the return value is 128
        plus the number of the signal which caused the program to
        stop or terminate.
 <p>AUTHOR <br>
        time was written by David MacKenzie.  This man page was added
        by Dirk Eddelbuettel <edd@debian.org>, the Debian GNU/Linux
        maintainer, for use by the Debian GNU/Linux distribution but
        may of course be used by others.
 
 <p>SEE ALSO <br>
        tcsh(1), printf(3)
 
 
   
</div>

</div>
<script src="../app.js"></script>

</body>
</html>